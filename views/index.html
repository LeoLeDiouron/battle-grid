<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>BattleGrid</title>
    <script src="./phaser.min.js"></script>
    <script src="./phaser-input.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

    /*  _________________________________ GLOBAL VARIABLES _________________________________ */

    // about graphics
    let windowWidth = window.innerWidth;
    let windowHeight = window.innerHeight;
    let sizeScreenChanged = false;
    const game = new Phaser.Game(windowWidth, windowHeight, Phaser.AUTO, 'battle-grid', { preload: preload, create: create, update: update });
    let idxFrame = 0;
    let graphics = null;

    // about scene management
    let idPlayer = null;
    let idRoom = null;
    let statusRoom = 0;
    let validateArmy = false;
    let menuItems = initMenuItems();
    let waitingItems = initWaitingItems();
    let joinItems = initJoinItems();
    let selectionItems = initSelectionItems();
    let gameItems = initGameItems();
    let winnerItems = initWinnerItems();

    // about selection scene
    let money = null;
    let army = null;

    // about graphics (in round)
    const sizeGrid = 15;
    const sizeCell = 45;
    const beginX = (windowWidth / 2) - (sizeCell * sizeGrid / 2);
    const beginY = (windowHeight / 2) - (sizeCell * sizeGrid / 2);

    // about gameplay
    let statusGame = null;
    let statusGameChanged = null;
    let myTurn = null;
    const listUnits = ["peasant", "soldier", "bowman", "ninja", "doctor", "knight", "crossbowman", "necromancer"];
    const selectionInfoUnit = {
        peasant: {
            description: "Pesant: basic unit. (10 gold)",
            price: 10
        },
        soldier: {
            description: "Soldier: just a peasant with an armor. (20 gold)",
            price: 20
        },
        bowman: {
            description: "Bowman: mysterious and pretty accurate. (30 gold)",
            price: 30
        },
        ninja: {
            description: "Ninja: fast. strong. handsome. (40 gold)",
            price: 40
        },
        doctor: {
            description: "Doctor: here to repay his studies's debt. (50 gold)",
            price: 50
        },
        knight: {
            description: "Knight: really heavy baby. (60 gold)",
            price: 60
        },
        crossbowman: {
            description: "Crossbowman: unofficial son of Guillaume Tell. (70 gold)",
            price: 70
        },
        necromancer: {
            description: "Necromancer: death is never definitive. (100 gold)",
            price: 100
        },
    }

    // about api
    const baseUrl = "/api";

    /*  _________________________________ PHASER FUNCTIONS _________________________________ */

    function preload() {
        // plugin for input
        game.add.plugin(PhaserInput.Plugin);
        // load menu buttons
        game.load.image('new', 'assets/images/menu/new.png');
        game.load.image('join', 'assets/images/menu/join.png');
        game.load.image('random', 'assets/images/menu/random.png');
        // load join buttons
        game.load.image('back', 'assets/images/menu/back.png');
        // load selection buttons
        game.load.image('validate', 'assets/images/selection/validate.png');
        game.load.image('more', 'assets/images/selection/more.png');
        game.load.image('less', 'assets/images/selection/less.png');
        // load units
        game.load.image('peasant', 'assets/images/units/peasant.png');
        game.load.image('soldier', 'assets/images/units/soldier.png');
        game.load.image('ninja', 'assets/images/units/ninja.png');
        game.load.image('knight', 'assets/images/units/knight.png');
        game.load.image('bowman', 'assets/images/units/bowman.png');
        game.load.image('king', 'assets/images/units/king.png');
        game.load.image('doctor', 'assets/images/units/doctor.png');
        game.load.image('crossbowman', 'assets/images/units/crossbowman.png');
        game.load.image('necromancer', 'assets/images/units/necromancer.png');
        game.load.image('zombie', 'assets/images/units/zombie.png');
        // load images action
        game.load.image('attack', 'assets/images/round/attack.png');
        game.load.image('move', 'assets/images/round/move.png');
        game.load.image('range', 'assets/images/round/range.png');
        game.load.image('blocked', 'assets/images/round/blocked.png');
        game.load.image('enemyBorder', 'assets/images/round/enemy_border.png');
        game.load.image('enemyRange', 'assets/images/round/enemy_range.png');
        // load background
        game.load.image('fog', 'assets/images/round/fog.png');
        game.load.image('damaged', 'assets/images/round/damaged.png');
        game.load.image('obstacle', 'assets/images/round/areas/desert/obstacle.png');
        game.load.image('ground1', 'assets/images/round/areas/desert/ground1.png');
        game.load.image('ground2', 'assets/images/round/areas/desert/ground2.png');
        game.load.image('ground3', 'assets/images/round/areas/desert/ground3.png');
        game.load.image('ground4', 'assets/images/round/areas/desert/ground4.png');
        game.load.image('ground5', 'assets/images/round/areas/desert/ground5.png');
        // load end buttons
        game.load.image('retry', 'assets/images/menu/retry.png');
        // load font
        game.load.bitmapFont('font', 'assets/fonts/font.png', 'assets/fonts/font.xml');
    }

    async function create() {
        idPlayer = sendRequest(baseUrl + "/id_player", "GET").idPlayer;
        console.log(`id player : ${idPlayer}`);
        displayMenu();
    }

    function update() {
        if (idxFrame % 10 == 0) {
            responsive();
            if (idRoom !== null) {
                tmpStatusRoom = sendRequest(baseUrl + "/status_room/" + idRoom, "GET");
                if (tmpStatusRoom.status === 2 && statusRoom === 1) { // two players are here, need to select army
                    destroyWaiting();
                    displaySelection();
                } else if (tmpStatusRoom.status === 3 && statusRoom === 2) { // two players choosed their army, start game
                    statusGame = sendRequest(baseUrl + "/status_game/" + idRoom + "?idPlayer=" + idPlayer, "GET");
                    destroySelection();
                    displayGrid();
                    checkTurnOver();
                    displayArmies();
                } else if (tmpStatusRoom.status === 4 && statusRoom === 3) { // one player win
                    destroyGrid();
                    displayWinner(tmpStatusRoom.winner);
                }
                statusRoom = tmpStatusRoom.status;
                 if (statusRoom === 3) {
                    const tmpStatusGame = sendRequest(baseUrl + "/status_game/" + idRoom + "?idPlayer=" + idPlayer, "GET");
                    if (statusGameChanged === null || JSON.stringify(tmpStatusGame) !== JSON.stringify(statusGame)) {
                        statusGameChanged = true;
                    } else {
                        statusGameChanged = false;
                    }
                    statusGame = tmpStatusGame;
                    if (statusGame.turnPlayer === idPlayer) {
                        myTurn = true;
                    } else {
                        myTurn = false;
                    }
                    checkTurnOver();
                    displayArmies();
                }
            }
        } else {
            if (idRoom === null) {
                for (let i = 0; i < menuItems.images.length; i++) {
                    menuItems.images[i].x += 1;
                    if (menuItems.images[i].x >= windowWidth) {
                        menuItems.images[i].x = 0;
                    }
                }
            }
        }
        idxFrame++;
    }

    /* _________________________________ SCENE 0 - MENU _________________________________ */

    function displayMenu() {
        // add line
        const line = new Phaser.Line(0, windowHeight / 2, windowWidth, 0);
        menuItems.graphics = game.add.graphics(line.start.x,line.start.y);
        menuItems.graphics.lineStyle(3, 0xFFFFFF, 1);
        menuItems.graphics.lineTo(line.end.x,line.end.y);
        menuItems.graphics.endFill();
        // add title
        menuItems.title = game.add.bitmapText(0, windowHeight / 2 - 60, 'font', 'BATTLE GRID', 40);
        menuItems.title.x = windowWidth / 2 - menuItems.title.width - 10;
        // add menu buttons
        menuItems.buttons["new"] = game.add.button(windowWidth / 2, windowHeight / 2 + 25, "new", () => {createRoom();});
        menuItems.buttons["new"].scale.setTo(0.1, 0.1);
        menuItems.buttons["join"] = game.add.button(windowWidth / 2, windowHeight / 2 + 75, "join", () => {joinRoom();});
        menuItems.buttons["join"].scale.setTo(0.1, 0.1);
        menuItems.buttons["random"] = game.add.button(windowWidth / 2, windowHeight / 2 + 125, "random", () => {randomRoom();});
        menuItems.buttons["random"].scale.setTo(0.1, 0.1);
        // add menu text
        menuItems.text["new"] = game.add.bitmapText(windowWidth / 2 + 50, windowHeight / 2 + 25, 'font', 'NEW GAME', 30);
        menuItems.text["join"] = game.add.bitmapText(windowWidth / 2 + 50, windowHeight / 2 + 75, 'font', 'JOIN GAME', 30);
        menuItems.text["random"] = game.add.bitmapText(windowWidth / 2 + 50, windowHeight / 2 + 125, 'font', 'RANDOM GAME', 30);
        menuItems.text["errorMessage"] = game.add.bitmapText(windowWidth / 2 , windowHeight / 2 + 175, 'font', '', 30);
        // add images
        let x = 0;
        for (const unit of listUnits) {
            const spriteUnit = game.add.image(0, windowHeight / 2 - 60, unit);
            spriteUnit.scale.setTo(0.15, 0.15)
            spriteUnit.centerX = 0 + spriteUnit.width / 2 + x * (spriteUnit.width + 10);
            menuItems.images.push(spriteUnit);
            x++;
        }
    }

    function destroyMenu() {
        menuItems.graphics.destroy();
        menuItems.title.destroy();
        for (const [buttonKey, buttonValue] of Object.entries(menuItems.buttons)) {
            menuItems.buttons[buttonKey].destroy();
        }
        for (const [textKey, textValue] of Object.entries(menuItems.text)) {
            menuItems.text[textKey].destroy();
        }
        for (let i = 0; i < menuItems.images.length; i++) {
            menuItems.images[i].destroy();
        }
        menuItems = initMenuItems();
    }

    function initMenuItems() {
        return {
            title: null,
            graphics: null,
            buttons: {},
            text: {},
            images: []
        };
    }

    function createRoom() {
        destroyMenu();
        idRoom = sendRequest(baseUrl + "/create_room?idPlayer=" + idPlayer, "GET").idRoom;
        displayWaiting();
    }

    function joinRoom() {
        destroyMenu();
        displayJoin();
    }

    function randomRoom() {
        idRoom = sendRequest(baseUrl + "/random_room?idPlayer=" + idPlayer, "GET").idRoom;
        if (idRoom !== null) {
            destroyMenu();
            displaySelection();
        } else {
            menuItems.text["errorMessage"].text = "No game found, sorry bro.";
            menuItems.text["errorMessage"].tint = 0xFF0000;
        }
    }

    /* _________________________________ SCENE 1 - WAITING _________________________________ */

    function displayWaiting() {
        // add line
        const line = new Phaser.Line(0, windowHeight / 2, windowWidth, 0);
        waitingItems.graphics = game.add.graphics(line.start.x,line.start.y);
        waitingItems.graphics.lineStyle(3, 0xFFFFFF, 1);
        waitingItems.graphics.lineTo(line.end.x,line.end.y);
        waitingItems.graphics.endFill();
        // add title
        waitingItems.title = game.add.bitmapText(0, windowHeight / 2 - 60, 'font', 'NEW GAME', 40);
        waitingItems.title.x = windowWidth / 2 - waitingItems.title.width - 10;
        // add id room
        waitingItems.room = game.add.bitmapText(windowWidth / 2, windowHeight / 2 + 25, 'font', `code of your game: ${idRoom}`, 30);
    }

    function destroyWaiting() {
        if (waitingItems.title !== null) {
            waitingItems.graphics.destroy();
            waitingItems.title.destroy();
            waitingItems.room.destroy();
            waitingItems = initWaitingItems();
        }
    }

    function initWaitingItems() {
        return {
            title: null,
            graphics: null,
            room: null
        };
    }

    /* _________________________________ SCENE 1.1 - JOIN _________________________________ */

    function displayJoin() {
        // add line
        const line = new Phaser.Line(0, windowHeight / 2, windowWidth, 0);
        joinItems.graphics = game.add.graphics(line.start.x,line.start.y);
        joinItems.graphics.lineStyle(3, 0xFFFFFF, 1);
        joinItems.graphics.lineTo(line.end.x,line.end.y);
        joinItems.graphics.endFill();
        // add title
        joinItems.title = game.add.bitmapText(0, windowHeight / 2 - 60, 'font', 'JOIN A GAME', 40);
        joinItems.title.x = windowWidth / 2 - joinItems.title.width - 10;
        // add input
        joinItems.input = game.add.inputField(windowWidth / 2, windowHeight / 2 + 25, { width: 150, padding: 8 });
        // add button validation
        joinItems.buttonValidation = game.add.button(windowWidth / 2, windowHeight / 2 + 75, "validate", () => {joinARoom(joinItems.input.value)});
        joinItems.buttonValidation.scale.setTo(0.12, 0.12);
        // add error message
        joinItems.errorMessage = game.add.bitmapText(windowWidth / 2, windowHeight / 2 + 125, "font", "", 30);
        // add back button
        joinItems.backButton = game.add.button(10, 10, "back", () => {backToMenuFromJoin()});
        joinItems.backButton.scale.setTo(0.17, 0.17);
    }

    function joinARoom(codeRoom) {
        const response = sendRequest(baseUrl + "/join_room/" + codeRoom + "?idPlayer=" + idPlayer, "GET", null);
        if (response.status === 0) {
            idRoom = codeRoom;
            destroyJoin();
            displaySelection();
        } else {
            joinItems.errorMessage.tint = 0xFFFFFF;
            joinItems.errorMessage.text = response.errorMessage;
        }
    }

    function destroyJoin() {
        joinItems.graphics.destroy();
        joinItems.title.destroy();
        joinItems.input.destroy();
        joinItems.buttonValidation.destroy();
        joinItems.backButton.destroy();
        joinItems.errorMessage.destroy();
        joinItems = initJoinItems();
    }

    function backToMenuFromJoin() {
        destroyJoin();
        displayMenu();
    }

    function initJoinItems() {
        return {
            title: null,
            graphics: null,
            input: null,
            buttonValidation: null,
            backButton: null,
            errorMessage: null,
            room: null
        };
    }

    /* _________________________________ SCENE 2 - SELECTION _________________________________ */

    function displaySelection() {
        money = 200;
        army = initalizeArmy();
        // add title
        selectionItems.title = game.add.bitmapText(0, windowHeight / 2 - 300, 'font', 'SELECT YOUR UNITS', 40);
        selectionItems.title.centerX = windowWidth / 2;
        // add line money
        selectionItems.text['money'] = game.add.bitmapText(0, windowHeight / 2 - 200, 'font', `${money} gold`, 30);
        selectionItems.text['money'].centerX = windowWidth / 2;
        // add buttons selection
        let idx = 0 - listUnits.length / 2;
        for (const unit of listUnits) {
            selectionItems.buttons[unit] = game.add.button(windowWidth / 2 + (idx * 150), windowHeight / 2, unit, () => {displayUnitDetails(unit);});
            selectionItems.buttons[unit].scale.setTo(0.5, 0.5);
            // button more
            selectionItems.buttons[unit + "_more"] = game.add.button(0, 0, "more", () => {addUnit(unit);});
            selectionItems.buttons[unit + "_more"].scale.setTo(0.15, 0.15);
            selectionItems.buttons[unit + "_more"].centerX = selectionItems.buttons[unit].centerX;
            selectionItems.buttons[unit + "_more"].centerY = selectionItems.buttons[unit].centerY - selectionItems.buttons[unit].height / 2 - selectionItems.buttons[unit + "_more"].height / 2 - 10;
            // button less
            selectionItems.buttons[unit + "_less"] = game.add.button(0, 0, "less", () => {removeUnit(unit);});
            selectionItems.buttons[unit + "_less"].scale.setTo(0.15, 0.15);
            selectionItems.buttons[unit + "_less"].centerX = selectionItems.buttons[unit].centerX;
            selectionItems.buttons[unit + "_less"].centerY = selectionItems.buttons[unit].centerY + selectionItems.buttons[unit].height / 2 + selectionItems.buttons[unit + "_less"].height / 2 + 10;
            // number of units
            selectionItems.text[unit + "_number"] = game.add.bitmapText(0, 0, 'font', "x0", 30);
            selectionItems.text[unit + "_number"].centerX = selectionItems.buttons[unit].centerX;
            selectionItems.text[unit + "_number"].centerY = selectionItems.buttons[unit + "_less"].centerY + selectionItems.buttons[unit + "_less"].height / 2 + selectionItems.text[unit + "_number"].height / 2 + 10;
            idx++;
        }
        // add tips
        selectionItems.text['tips'] = game.add.bitmapText(0, windowHeight / 2 + 300, 'font', "click on an unit to see its details", 30);
        selectionItems.text['tips'].centerX = windowWidth / 2;
        // add button validate
        selectionItems.buttons['validate'] = game.add.button(0, windowHeight - 100, "validate", () => {createArmy()});
        selectionItems.buttons['validate'].scale.setTo(0.2, 0.2);
        selectionItems.buttons['validate'].centerX = windowWidth / 2;
    }

    function initalizeArmy() {
        return {
            peasant: 0,
            soldier: 0,
            ninja: 0,
            knight: 0,
            bowman: 0,
            doctor: 0,
            crossbowman: 0,
            necromancer: 0
        };
    }

    function destroySelection() {
        selectionItems.title.destroy();
        for (const [buttonKey, buttonValue] of Object.entries(selectionItems.buttons)) {
            selectionItems.buttons[buttonKey].destroy();
        }
        for (const [textKey, textValue] of Object.entries(selectionItems.text)) {
            selectionItems.text[textKey].destroy();
        }
        selectionItems = initSelectionItems();
    }

    function displayUnitDetails(unit) {
        selectionItems.text['tips'].text = selectionInfoUnit[unit].description;
        selectionItems.text['tips'].centerX = windowWidth / 2;
    }

    function disaplayChange(unit) {
        selectionItems.text[unit + "_number"].text = `x${army[unit]}`;
        selectionItems.text[unit + "_number"].centerX = selectionItems.buttons[unit].centerX;
        selectionItems.text['money'].text = `${money} gold`;
        selectionItems.text['money'].centerX = windowWidth / 2;
    }

    function addUnit(unit) {
        if (validateArmy === false && money >= selectionInfoUnit[unit].price) {
            army[unit]++;
            money -= selectionInfoUnit[unit].price;
            disaplayChange(unit);
        }
    }

    function removeUnit(unit) {
        if (validateArmy === false && army[unit] > 0) {
            army[unit]--;
            money += selectionInfoUnit[unit].price;
            disaplayChange(unit);
        }
    }

    function initSelectionItems() {
        return {
            title: null,
            buttons: {},
            text: {}
        };
    }

    function createArmy() {
        validateArmy = true;
        selectionItems.buttons['validate'].destroy();
        delete selectionItems.buttons['validate'];
        const url = `${baseUrl}/create_army/${idRoom}?idPlayer=${idPlayer}`;
        sendRequest(url, "POST", JSON.stringify({
            army: army
        }));
    }

    /* _________________________________ SCENE 3 - ROUND _________________________________ */

    function displayGrid() {
        gameItems.text["turn"] = game.add.bitmapText(beginX, beginY - 80, 'font', '', 30);
        gameItems.text["statsLine"] = game.add.bitmapText(beginX, beginY - 50, 'font', '', 30);
        gameItems.graphics = game.add.graphics(beginX, beginY);
        gameItems.graphics.lineStyle(2, 0xFFFFFF, 1);
        gameItems.images["ground"] = [];
        for (let x = 0; x < sizeGrid; x++) {
            for (let y = 0; y < sizeGrid; y++) {
                gameItems.graphics.drawRect(x * sizeCell, y * sizeCell, sizeCell, sizeCell);
                const imgGround = game.add.image(beginX + (x * sizeCell), beginY + (y * sizeCell), "ground" + (1 + random(5)));
                imgGround.scale.setTo(0.17, 0.17);
                gameItems.images.ground.push(imgGround);
            }
        }
        gameItems.images["obstacles"] = [];
        for (const obstacle of statusGame.obstacles) {
            const x = (idPlayer === statusGame.firstPlayer) ? beginX + (obstacle.x * sizeCell) : beginX + ((14 - obstacle.x) * sizeCell);
            const y = (idPlayer === statusGame.firstPlayer) ? beginY + (obstacle.y * sizeCell) : beginY + ((14 - obstacle.y) * sizeCell);
            const imgObstacle = game.add.image(x, y, "obstacle");
            imgObstacle.scale.setTo(0.17, 0.17);
            gameItems.images.obstacles.push(imgObstacle);
        }
        gameItems.images["fog"] = [];
    }

    function destroyGrid() {
        gameItems.graphics.destroy();
        if ("myArmy" in gameItems.buttons && "enemyArmy" in gameItems.buttons) {
            destroyArmies();
        }
        if ("move" in gameItems.buttons) {
            destroyMoveButtons();
        }
        if ("blocked" in gameItems.buttons) {
            destroyBlockedButtons();
        }
        if ("enemiesBorder" in gameItems.buttons) {
            destroyEnemiesButtons();
        }
        if ("obstacles" in gameItems.images) {
            destroyObstacles();
        }
        if ("ground" in gameItems.images) {
            destroyGround();
        }
        if ("damaged" in gameItems.buttons) {
            destroyDamagedButtons();
        }
        for (const [textKey, textValue] of Object.entries(gameItems.text)) {
            gameItems.text[textKey].destroy();
        }
        gameItems = initGameItems();
    }

    function displayArmies() {
        if (statusGameChanged === false && sizeScreenChanged === false) {
            return;
        }
        if ("myArmy" in gameItems.buttons && "enemyArmy" in gameItems.buttons) {
            destroyArmies();
            destroyBlockedButtons();
            destroyEnemiesButtons();
            destroyDamagedButtons();
        }
        gameItems.buttons["myArmy"] = {};
        gameItems.buttons["enemyArmy"] = {};
        gameItems.buttons["blocked"] = [];
        gameItems.buttons["enemiesBorder"] = [];
        gameItems.buttons["damaged"] = [];
        for (const unit of statusGame.myArmy) {
            addUnitButton(unit, "myArmy", () => {event(unit)})
        }
        for (const unit of statusGame.enemyArmy) {
            addUnitButton(unit, "enemyArmy", () => {eventEnemy(unit)})
        }
        applyFog();
    }

    function addUnitButton(unit, army, event) {
        if (inVisionOfArmy(unit.x, unit.y) === false) {
            return;
        }
        const x = (idPlayer === statusGame.firstPlayer) ? beginX + (unit.x * sizeCell) : beginX + ((14 - unit.x) * sizeCell);
        const y = (idPlayer === statusGame.firstPlayer) ?  beginY  + (unit.y * sizeCell) : beginY  + ((14 - unit.y) * sizeCell);
        // add sprite unit
        const unitButton = game.add.button(x, y, unit.type, event);
        unitButton.scale.setTo(0.17, 0.17);
        gameItems.buttons[army][unit.idx] = unitButton;
        // add enemy border
        if (army === "enemyArmy") {
            const enemyBorder = game.add.button(x, y, "enemyBorder", event);
            enemyBorder.scale.setTo(0.15, 0.15);
            gameItems.buttons.enemiesBorder.push(enemyBorder);
        }
        // add blocked icon
        if (unit.hasAttacked === true) {
            const blockedButton = game.add.button(x, y, "blocked", event);
            blockedButton.scale.setTo(0.17, 0.17);
            gameItems.buttons.blocked.push(blockedButton);
        }
        // add damaged effect
        if (unit.hp <= 4) {
            const damagedButton = game.add.button(x, y, "damaged", event);
            damagedButton.scale.setTo(0.17, 0.17);
            damagedButton.alpha = 0.3;
            gameItems.buttons.damaged.push(damagedButton);
        }
    }

    function inVisionOfArmy(x, y) {
        for (const unit of statusGame.myArmy) {
            if (x <= unit.x + (unit.move * 1.5 + unit.range) && x >= unit.x - (unit.move * 1.5 + unit.range) &&
                y <= unit.y + (unit.move * 1.5 + unit.range) && y >= unit.y - (unit.move * 1.5 + unit.range)) {
                    return true;
            }
        }
        return false;
    }

    function applyFog() {
        if ("fog" in gameItems.images) {
            destroyFog();
        }
        for (let x = 0; x < sizeGrid; x++) {
            for (let y = 0; y < sizeGrid; y++) {
                if (inVisionOfArmy(x, y) === false) {
                    const fogX = (idPlayer === statusGame.firstPlayer) ? beginX + (x * sizeCell) : beginX + ((14 - x) * sizeCell);
                    const fogY = (idPlayer === statusGame.firstPlayer) ? beginY + (y * sizeCell) : beginY + ((14 - y) * sizeCell);
                    const imgFog = game.add.image(fogX, fogY, "fog");
                    imgFog.scale.setTo(0.17, 0.17);
                    imgFog.alpha = 0.7;
                    gameItems.images.fog.push(imgFog);
                }
            }
        }
    }

    function destroyArmies() {
        for (const [buttonKey, buttonValue] of Object.entries(gameItems.buttons.myArmy)) {
            gameItems.buttons.myArmy[buttonKey].destroy();
        }
        for (const [buttonKey, buttonValue] of Object.entries(gameItems.buttons.enemyArmy)) {
            gameItems.buttons.enemyArmy[buttonKey].destroy();
        }
    }

    function destroyBlockedButtons() {
        for (let idx = 0; idx < gameItems.buttons.blocked.length; idx++) {
            gameItems.buttons.blocked[idx].destroy();
        }
    }

    function destroyEnemiesButtons() {
        for (let idx = 0; idx < gameItems.buttons.enemiesBorder.length; idx++) {
            gameItems.buttons.enemiesBorder[idx].destroy();
        }
    }

    function destroyDamagedButtons() {
        for (let idx = 0; idx < gameItems.buttons.damaged.length; idx++) {
            gameItems.buttons.damaged[idx].destroy();
        }
    }

    function destroyMoveButtons() {
        for (let idx = 0; idx < gameItems.buttons.move.length; idx++) {
            gameItems.buttons.move[idx].destroy();
        }
    }

    function destroyObstacles() {
        for (let idx = 0; idx < gameItems.images.obstacles.length; idx++) {
            gameItems.images.obstacles[idx].destroy();
        }
    }

    function destroyFog() {
        for (let idx = 0; idx < gameItems.images.fog.length; idx++) {
            gameItems.images.fog[idx].destroy();
        }
    }

    function destroyGround() {
        for (let idx = 0; idx < gameItems.images.ground.length; idx++) {
            gameItems.images.ground[idx].destroy();
        }
    }

    function initGameItems() {
        return {
            graphics: null,
            buttons: {},
            text: {},
            images: {}
        };
    }

    function event(unit) {
        gameItems.text.statsLine.text = `Type: [${unit.type}] HP: [${unit.hp}/${unit.maxHp}] DMG: [${unit.dmg}]`;
        gameItems.text.statsLine.tint = 0xFFFFFF;
        if (myTurn === true && unit.hasAttacked === false) {
            manageMove(unit);
        }
    }

    function eventEnemy(unit) {
        gameItems.text.statsLine.text = `Type: [${unit.type}] HP: [${unit.hp}/${unit.maxHp}] DMG: [${unit.dmg}]`;
        gameItems.text.statsLine.tint = 0xFF0000;
        if (myTurn === true) {
            showRangeEnemy(unit);  
        }
    }

    function isOnAllie(offsetX, offsetY, currentUnit, inMyArmy) {
        for (const unit of statusGame.myArmy) {
            if ((unit.idx !== currentUnit.idx || inMyArmy === false) && unit.x === offsetX && unit.y === offsetY) {
                return true;
            }
        }
        return false;
    }

    function isOnObstacle(x, y) {
        for (const obstacle of statusGame.obstacles) {
            if (x === obstacle.x && y === obstacle.y) {
                return true;
            }
        }
        return false;
    }

    function haveToDisplayMove(offsetX, offsetY, unit, inMyArmy) {
        if (offsetX === unit.x && offsetY === unit.y) {
            return false;
        } else if (offsetX < 0 || offsetX >= sizeGrid) {
            return false;
        } else if (offsetY < 0 || offsetY >= sizeGrid) {
            return false;
        } else if (inMyArmy === true && isOnAllie(offsetX, offsetY, unit, inMyArmy) === true) {
            return false;
        } else if (inMyArmy === false && isOnEnemy(offsetX, offsetY) !== -1) {
            return false;
        } else if (isOnObstacle(offsetX, offsetY) === true) {
            return false;
        } else {
            return true;
        }
    }

    function isOnEnemy(offsetX, offsetY) {
        for (const unit of statusGame.enemyArmy) {
            if (unit.x === offsetX && unit.y === offsetY) {
                return unit.idx;
            }
        }
        return -1;
    }

    function manageMove(unit) {
        if ("move" in gameItems.buttons) {
            destroyMoveButtons();
        }
        gameItems.buttons["move"] = [];
        for (let offsetX = unit.x - (unit.move + unit.range); offsetX <= unit.x + (unit.move + unit.range); offsetX++) {
            for (let offsetY = unit.y - (unit.move + unit.range); offsetY <= unit.y + (unit.move + unit.range); offsetY++) {
                const idxEnemy = isOnEnemy(offsetX, offsetY);
                const x = (idPlayer === statusGame.firstPlayer) ? beginX + (offsetX * sizeCell) : beginX + ((14 - offsetX) * sizeCell);
                const y = (idPlayer === statusGame.firstPlayer) ?  beginY  + (offsetY * sizeCell) : beginY  + ((14 - offsetY) * sizeCell);
                if (idxEnemy !== -1) {
                    const buttonMove = game.add.button(x, y, 'attack', () => {attackEnemy(unit, idxEnemy)});
                    buttonMove.scale.setTo(0.17, 0.17);
                    gameItems.buttons["move"].push(buttonMove);
                } else if (haveToDisplayMove(offsetX, offsetY, unit, true)) {
                    let buttonMove = null;
                    if ((offsetX >= unit.x - unit.move && offsetX <= unit.x + unit.move) && (offsetY >= unit.y - unit.move && offsetY <= unit.y + unit.move)) {
                        buttonMove = game.add.button(x, y, 'move', () => {moveUnit(unit, offsetX, offsetY)});
                    } else {
                        buttonMove = game.add.button(x, y, 'range', () => {});
                    }
                    buttonMove.scale.setTo(0.17, 0.17);
                    gameItems.buttons["move"].push(buttonMove);
                }
            }
        }   
    }

    function showRangeEnemy(unit) {
        if ("move" in gameItems.buttons) {
            destroyMoveButtons();
        }
        gameItems.buttons["move"] = [];
        for (let offsetX = unit.x - (unit.move + unit.range); offsetX <= unit.x + (unit.move + unit.range); offsetX++) {
            for (let offsetY = unit.y - (unit.move + unit.range); offsetY <= unit.y + (unit.move + unit.range); offsetY++) {
                const onAllie = isOnAllie(offsetX, offsetY, unit, false);
                const canMove = haveToDisplayMove(offsetX, offsetY, unit, false);
                if (onAllie === false && canMove === true) {
                    const x = (idPlayer === statusGame.firstPlayer) ? beginX + (offsetX * sizeCell) : beginX + ((14 - offsetX) * sizeCell);
                    const y = (idPlayer === statusGame.firstPlayer) ?  beginY  + (offsetY * sizeCell) : beginY  + ((14 - offsetY) * sizeCell);
                    const buttonMove = game.add.button(x, y, 'enemyRange', () => {});
                    buttonMove.scale.setTo(0.17, 0.17);
                    gameItems.buttons["move"].push(buttonMove);
                }
            }
        }   
    }

    function attackEnemy(unit, idxEnemy) {
        destroyMoveButtons();
        const url = `${baseUrl}/attack/${idRoom}?idPlayer=${idPlayer}`;
        const body = {
            idx: unit.idx,
            idxEnemy: idxEnemy
        }
        sendRequest(url, "POST", JSON.stringify(body));
    }

    function moveUnit(unit, offsetX, offsetY) {
        destroyMoveButtons();
        const url = `${baseUrl}/move/${idRoom}?idPlayer=${idPlayer}`;
        const body = {
            idx: unit.idx,
            x: offsetX,
            y: offsetY
        }
        sendRequest(url, "POST", JSON.stringify(body));
    }

    function everyUnitHasAttacked() {
        for (const unit of statusGame.myArmy) {
            if (unit.hasAttacked === false) {
                return false;
            }
        }
        return true;
    }

    function checkTurnOver() {
        if (myTurn === true) {
            if (statusGame.nbActions <= 0 || everyUnitHasAttacked() === true) {
                const url = `${baseUrl}/turn_over/${idRoom}?idPlayer=${idPlayer}`;
                sendRequest(url, "GET");
                gameItems.text["turn"].text = `Enemy's turn - ${statusGame.nbActions}/4`;
            } else {
                gameItems.text["turn"].text = `Your turn - ${statusGame.nbActions}/4`;
            }
        } else {
            gameItems.text["turn"].text = `Enemy's turn - ${statusGame.nbActions}/4`;
        }
    }

    /* _________________________________ SCENE 4 - WINNER _________________________________ */

    function displayWinner(idWinner) {
        // add title and icon
        winnerItems.title = game.add.bitmapText(0, 0, 'font', '', 40);
        winnerItems.icon = game.add.image(0, 0, "king");
        if (idWinner === idPlayer) {
            winnerItems.title.text = "YOU WIN !";
            winnerItems.icon.scale.setTo(0.5, 0.5);
        } else {
            winnerItems.title.text = "YOU LOSE";
            winnerItems.icon.scale.setTo(0.5, -0.5);
        }
        winnerItems.title.centerX = windowWidth / 2;
        winnerItems.title.centerY = windowHeight / 2;
        winnerItems.icon.centerX = windowWidth / 2;
        winnerItems.icon.centerY = windowHeight / 2 - winnerItems.icon.height;
        // add button back
        winnerItems.buttonBack = game.add.button(0, 0, "back", () => {backToMenuFromEnd();});
        winnerItems.buttonBack.scale.setTo(0.17, 0.17);
        winnerItems.buttonBack.centerX = windowWidth / 2 - winnerItems.title.width;
        winnerItems.buttonBack.centerY = windowHeight / 2;
        // add button retry
        winnerItems.buttonRetry = game.add.button(0, 0, "retry", () => {retry();});
        winnerItems.buttonRetry.scale.setTo(0.17, 0.17);
        winnerItems.buttonRetry.centerX = windowWidth / 2 + winnerItems.title.width;
        winnerItems.buttonRetry.centerY = windowHeight / 2;
    }

    function reInit(newIdRoom, newStatusRoom) {
        idRoom = newIdRoom;
        statusRoom = 0;
        statusGame = null;
        statusGameChanged = null;
        myTurn = null;
        validateArmy = false;
    }

    function backToMenuFromEnd() {
        reInit(null);
        destroyWinnerMenu();
        displayMenu();
    }

    function retry() {
        reInit(idRoom);
        destroyWinnerMenu();
        const response = sendRequest(`${baseUrl}/reinit_room/${idRoom}?idPlayer=${idPlayer}`, "GET");
        if (response.firstToRetry === false) {
            displaySelection();
        }
    }

    function destroyWinnerMenu() {
        winnerItems.title.destroy();
        winnerItems.icon.destroy();
        winnerItems.buttonRetry.destroy();
        winnerItems.buttonBack.destroy();
        winnerItems = initWinnerItems();
    }

    function initWinnerItems() {
        return {
            title: null,
            icon: null,
            buttonRetry: null,
            buttonBack: null
        }
    }

    /* _________________________________ TOOLS _________________________________ */

    function responsive() {
        if (windowWidth !== window.innerWidth || windowHeight !== window.innerHeight) {
            console.log(`${windowWidth} -> ${window.innerWidth} and ${windowHeight} -> ${window.innerHeight}`);
            sizeScreenChanged = true;
            windowWidth = window.innerWidth;
            windowHeight = window.innerHeight;
            game.width = windowWidth;
            game.height = windowHeight;
            if (idRoom === null) {
                console.log('MENU');
                destroyMenu();
                displayMenu();
            } else if (statusRoom === 1) {
                console.log('WAITING');
                destroyWaiting();
                displayWaiting();
            } else if (statusRoom === 2) {
                console.log('SELECTION');
                destroySelection();
                displaySelection();
            } else {
                console.log('GRID');
                destroyGrid();
                displayGrid();
                displayArmies();
            }
            sizeScreenChanged = false;
        }
    }

    function sendRequest(url, method, body=null) {
        const req = new XMLHttpRequest();
        req.open(method, url, false);
        if (method === "POST") {
            req.setRequestHeader("content-type", "application/json");
        }
        req.send(body);
        return JSON.parse(req.response);
    }

    function random(max) {
        return Math.floor(Math.random() * Math.floor(max));
    }
    
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

</script>

</body>
</html>