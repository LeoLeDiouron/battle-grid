<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>BattleGrid</title>
    <!-- phaser imports -->
    <script src="./phaser.min.js"></script>
    <script src="./phaser-input.js"></script>
    <!-- custom imports -->
    <script src="./views/js/loadAssets.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

    /*  _________________________________ GLOBAL VARIABLES _________________________________ */

    // about graphics
    let windowWidth = window.innerWidth;
    let windowHeight = window.innerHeight;
    let sizeScreenChanged = false;
    let game = new Phaser.Game(windowWidth, windowHeight, Phaser.AUTO, 'battle-grid', { preload: preload, create: create, update: update });
    let idxFrame = 0;
    let graphics = null;

    // about scene management
    let idPlayer = null;
    let idRoom = null;
    let statusRoom = 0;
    let config = null;
    let validateArmy = false;
    let menuItems = initMenuItems();
    let waitingItems = initWaitingItems();
    let joinItems = initJoinItems();
    let selectionLeaderItems = initSelectionLeaderItems();
    let selectionItems = initSelectionItems();
    let gameItems = initGameItems();
    let winnerItems = initWinnerItems();

    // about selection scene
    let money = null;
    let nbUnits = null;
    let army = null;
    let myLeader = null;

    // about graphics (in round)
    const sizeGrid = 15;
    const sizeCell = 45;
    const beginX = (windowWidth / 2) - (sizeCell * sizeGrid / 2);
    const beginY = (windowHeight / 2) - (sizeCell * sizeGrid / 2);
    let beginTurn = null;

    // about gameplay
    let statusGame = null;
    let statusGameChanged = null;
    let myTurn = null;
    let selectedUnit = null;
    const listLeaders = ["rich_king", "queen_of_slaves", "ulfrik_the_terror"];
    const listUnits = ["peasant", "shieldman", "soldier", "bowman", "ninja", "crossbowman", "doctor", "knight", "necromancer"];

    // about animations
    listSprite = null;
    listAnimations = null;
    nbAnimations = 0;

    // about api
    const baseUrl = "/api";

    /*  _________________________________ PHASER FUNCTIONS _________________________________ */

    function preload() {
        game = loadAssets(game);
    }

    async function create() {
        config = sendRequest(baseUrl + "/config", "GET").config;
        idPlayer = sendRequest(baseUrl + "/id_player", "GET").idPlayer;
        displayMenu();
    }

    async function update() {
        if (idxFrame % 10 == 0) {
            responsive();
            if (idRoom !== null) {
                tmpStatusRoom = sendRequest(baseUrl + "/status_room/" + idRoom, "GET");
                if (tmpStatusRoom.status === 2 && statusRoom === 1) { // two players are here, need to select army
                    destroyWaiting();
                    displaySelectionLeader();
                } else if (tmpStatusRoom.status === 3 && statusRoom === 2) { // two players choosed their army, start game
                    statusGame = sendRequest(baseUrl + "/status_game/" + idRoom + "?idPlayer=" + idPlayer, "GET");
                    destroySelection();
                    displayGrid();
                    checkTurnOver();
                    displayArmies();
                } else if (tmpStatusRoom.status === 4 && statusRoom === 3) { // one player win
                    destroyGrid();
                    displayWinner(tmpStatusRoom.winner);
                }
                statusRoom = tmpStatusRoom.status;
                 if (statusRoom === 3) {
                    while (nbAnimations > 0) {
                        await sleep(1000);
                        continue;
                     }
                    const tmpStatusGame = sendRequest(baseUrl + "/status_game/" + idRoom + "?idPlayer=" + idPlayer, "GET");
                    if (statusGameChanged === null || JSON.stringify(tmpStatusGame) !== JSON.stringify(statusGame)) {
                        statusGameChanged = true;
                    } else {
                        statusGameChanged = false;
                    }
                    statusGame = tmpStatusGame;
                    if (statusGame.turnPlayer === idPlayer) {
                        if (myTurn === null || myTurn === false) {
                            beginTurn = true;
                        }
                        myTurn = true;
                    } else {
                        myTurn = false;
                    }
                    checkTurnOver();
                    displayArmies();
                    if (statusGame.animations.length > 0) {
                        displayAnimations();
                    }
                }
            }
        } else {
            if (idRoom === null) {
                for (let i = 0; i < menuItems.images.length; i++) {
                    menuItems.images[i].x += 1;
                    if (menuItems.images[i].x >= windowWidth) {
                        menuItems.images[i].x = 0;
                    }
                }
            }
        }
        idxFrame++;
    }

    /* _________________________________ SCENE 0 - MENU _________________________________ */

    function displayMenu() {
        // add line
        const line = new Phaser.Line(0, windowHeight / 2, windowWidth, 0);
        menuItems.graphics = game.add.graphics(line.start.x,line.start.y);
        menuItems.graphics.lineStyle(3, 0xFFFFFF, 1);
        menuItems.graphics.lineTo(line.end.x,line.end.y);
        menuItems.graphics.endFill();
        // add title
        menuItems.title = game.add.bitmapText(0, windowHeight / 2 - 60, 'font', 'BATTLE GRID', 40);
        menuItems.title.x = windowWidth / 2 - menuItems.title.width - 10;
        // add menu buttons
        menuItems.buttons["new"] = game.add.button(windowWidth / 2, windowHeight / 2 + 25, "new", () => {createRoom();});
        menuItems.buttons["new"].scale.setTo(0.1, 0.1);
        menuItems.buttons["join"] = game.add.button(windowWidth / 2, windowHeight / 2 + 75, "join", () => {joinRoom();});
        menuItems.buttons["join"].scale.setTo(0.1, 0.1);
        menuItems.buttons["random"] = game.add.button(windowWidth / 2, windowHeight / 2 + 125, "random", () => {randomRoom();});
        menuItems.buttons["random"].scale.setTo(0.1, 0.1);
        // add menu text
        menuItems.text["new"] = game.add.bitmapText(windowWidth / 2 + 50, windowHeight / 2 + 25, 'font', 'NEW GAME', 30);
        menuItems.text["join"] = game.add.bitmapText(windowWidth / 2 + 50, windowHeight / 2 + 75, 'font', 'JOIN GAME', 30);
        menuItems.text["random"] = game.add.bitmapText(windowWidth / 2 + 50, windowHeight / 2 + 125, 'font', 'RANDOM GAME', 30);
        menuItems.text["errorMessage"] = game.add.bitmapText(windowWidth / 2 , windowHeight / 2 + 175, 'font', '', 30);
        // add images
        let x = 0;
        for (const unit of listUnits) {
            const spriteUnit = game.add.image(0, windowHeight / 2 - 60, unit);
            spriteUnit.scale.setTo(0.15, 0.15)
            spriteUnit.centerX = 0 + spriteUnit.width / 2 + x * (spriteUnit.width + 10);
            menuItems.images.push(spriteUnit);
            x++;
        }
    }

    function destroyMenu() {
        menuItems.graphics.destroy();
        menuItems.title.destroy();
        for (const [buttonKey, buttonValue] of Object.entries(menuItems.buttons)) {
            menuItems.buttons[buttonKey].destroy();
        }
        for (const [textKey, textValue] of Object.entries(menuItems.text)) {
            menuItems.text[textKey].destroy();
        }
        for (let i = 0; i < menuItems.images.length; i++) {
            menuItems.images[i].destroy();
        }
        menuItems = initMenuItems();
    }

    function initMenuItems() {
        return {
            title: null,
            graphics: null,
            buttons: {},
            text: {},
            images: []
        };
    }

    function createRoom() {
        destroyMenu();
        idRoom = sendRequest(baseUrl + "/create_room?idPlayer=" + idPlayer, "GET").idRoom;
        displayWaiting();
    }

    function joinRoom() {
        destroyMenu();
        displayJoin();
    }

    function randomRoom() {
        idRoom = sendRequest(baseUrl + "/random_room?idPlayer=" + idPlayer, "GET").idRoom;
        if (idRoom !== null) {
            destroyMenu();
            displaySelectionLeader();
        } else {
            menuItems.text["errorMessage"].text = "No game found, sorry bro.";
            menuItems.text["errorMessage"].tint = 0xFF0000;
        }
    }

    /* _________________________________ SCENE 1 - WAITING _________________________________ */

    function displayWaiting() {
        // add line
        const line = new Phaser.Line(0, windowHeight / 2, windowWidth, 0);
        waitingItems.graphics = game.add.graphics(line.start.x,line.start.y);
        waitingItems.graphics.lineStyle(3, 0xFFFFFF, 1);
        waitingItems.graphics.lineTo(line.end.x,line.end.y);
        waitingItems.graphics.endFill();
        // add title
        waitingItems.title = game.add.bitmapText(0, windowHeight / 2 - 60, 'font', 'NEW GAME', 40);
        waitingItems.title.x = windowWidth / 2 - waitingItems.title.width - 10;
        // add id room
        waitingItems.room = game.add.bitmapText(windowWidth / 2, windowHeight / 2 + 25, 'font', `code of your game: ${idRoom}`, 30);
    }

    function destroyWaiting() {
        if (waitingItems.title !== null) {
            waitingItems.graphics.destroy();
            waitingItems.title.destroy();
            waitingItems.room.destroy();
            waitingItems = initWaitingItems();
        }
    }

    function initWaitingItems() {
        return {
            title: null,
            graphics: null,
            room: null
        };
    }

    /* _________________________________ SCENE 1.1 - JOIN _________________________________ */

    function displayJoin() {
        // add line
        const line = new Phaser.Line(0, windowHeight / 2, windowWidth, 0);
        joinItems.graphics = game.add.graphics(line.start.x,line.start.y);
        joinItems.graphics.lineStyle(3, 0xFFFFFF, 1);
        joinItems.graphics.lineTo(line.end.x,line.end.y);
        joinItems.graphics.endFill();
        // add title
        joinItems.title = game.add.bitmapText(0, windowHeight / 2 - 60, 'font', 'JOIN A GAME', 40);
        joinItems.title.x = windowWidth / 2 - joinItems.title.width - 10;
        // add input
        joinItems.input = game.add.inputField(windowWidth / 2, windowHeight / 2 + 25, { width: 150, padding: 8 });
        // add button validation
        joinItems.buttonValidation = game.add.button(windowWidth / 2, windowHeight / 2 + 75, "validate", () => {joinARoom(joinItems.input.value)});
        joinItems.buttonValidation.scale.setTo(0.12, 0.12);
        // add error message
        joinItems.errorMessage = game.add.bitmapText(windowWidth / 2, windowHeight / 2 + 125, "font", "", 30);
        // add back button
        joinItems.backButton = game.add.button(10, 10, "back", () => {backToMenuFromJoin()});
        joinItems.backButton.scale.setTo(0.17, 0.17);
    }

    function joinARoom(codeRoom) {
        const response = sendRequest(baseUrl + "/join_room/" + codeRoom + "?idPlayer=" + idPlayer, "GET", null);
        if (response.status === 0) {
            idRoom = codeRoom;
            destroyJoin();
            displaySelectionLeader();
        } else {
            joinItems.errorMessage.tint = 0xFFFFFF;
            joinItems.errorMessage.text = response.errorMessage;
        }
    }

    function destroyJoin() {
        joinItems.graphics.destroy();
        joinItems.title.destroy();
        joinItems.input.destroy();
        joinItems.buttonValidation.destroy();
        joinItems.backButton.destroy();
        joinItems.errorMessage.destroy();
        joinItems = initJoinItems();
    }

    function backToMenuFromJoin() {
        destroyJoin();
        displayMenu();
    }

    function initJoinItems() {
        return {
            title: null,
            graphics: null,
            input: null,
            buttonValidation: null,
            backButton: null,
            errorMessage: null,
            room: null
        };
    }

    /* _________________________________ SCENE 2.1 - SELECTION OF LEADER _________________________________ */

    function displaySelectionLeader() {
        myLeader = null;
        // add title
        selectionLeaderItems.shadowTitle = game.add.bitmapText(0, windowHeight / 2 - 300 + 3, 'font', 'SELECT YOUR LEADER', 40);
        selectionLeaderItems.shadowTitle.centerX = windowWidth / 2 + 3;
        selectionLeaderItems.shadowTitle.tint = 0x0000FF;
        selectionLeaderItems.title = game.add.bitmapText(0, windowHeight / 2 - 300, 'font', 'SELECT YOUR LEADER', 40);
        selectionLeaderItems.title.centerX = windowWidth / 2;
        // add buttons selection
        let idx = Math.round(0 - listLeaders.length / 2 + 0.5);
        for (const leader of listLeaders) {
            addSelectionLeader(leader, idx);
            idx++;
        }
        // add description
        selectionLeaderItems.text['description'] = game.add.bitmapText(0, windowHeight / 2 + 300, 'font', "click on an leader to see its details", 30);
        selectionLeaderItems.text['description'].centerX = windowWidth / 2;
    }

    function addSelectionLeader(leader, idx) {
        // leader asset
        selectionLeaderItems.buttons[leader] = game.add.button(0, 0, leader, () => {selectLeader(leader, windowWidth / 2 + (idx * 300), windowHeight / 2);});
        selectionLeaderItems.buttons[leader].scale.setTo(0.7, 0.7);
        selectionLeaderItems.buttons[leader].centerX = windowWidth / 2 + (idx * 300);
        selectionLeaderItems.buttons[leader].centerY = windowHeight / 2;
    }

    function destroySelectionLeader() {
        selectionLeaderItems.title.destroy();
        selectionLeaderItems.shadowTitle.destroy();
        selectionLeaderItems.border.destroy();
        for (const [buttonKey, buttonValue] of Object.entries(selectionLeaderItems.buttons)) {
            selectionLeaderItems.buttons[buttonKey].destroy();
        }
        for (const [textKey, textValue] of Object.entries(selectionLeaderItems.text)) {
            selectionLeaderItems.text[textKey].destroy();
        }
        selectionLeaderItems = initSelectionLeaderItems();
    }

    function initSelectionLeaderItems() {
        return {
            title: null,
            shadowTitle: null,
            buttons: {},
            text: {},
            border: null
        };
    }

    function selectLeader(selectedLeader, centerX, centerY) {
        myLeader = selectedLeader;
        if (selectionLeaderItems.border !== null) {
            selectionLeaderItems.border.destroy();
        }
        selectionLeaderItems.border = game.add.image(0, 0, "redBorder");
        selectionLeaderItems.border.scale.setTo(0.7, 0.7);
        selectionLeaderItems.border.centerX = centerX;
        selectionLeaderItems.border.centerY = centerY;
        selectionLeaderItems.text['description'].text = config.leaders[selectedLeader].description;
        selectionLeaderItems.text['description'].centerX = windowWidth / 2;
        // add button validate
        if (!("validate" in selectionLeaderItems.buttons)) {
            selectionLeaderItems.buttons['validate'] = game.add.button(0, windowHeight - 100, "validate", () => {validateLeader()});
            selectionLeaderItems.buttons['validate'].scale.setTo(0.2, 0.2);
            selectionLeaderItems.buttons['validate'].centerX = windowWidth / 2;
        }
    }

    function validateLeader() {
        destroySelectionLeader();
        displaySelection();
    }

    /* _________________________________ SCENE 2.2 - SELECTION OF ARMY _________________________________ */

    function displaySelection() {
        money = (myLeader === "rich_king") ? config.round.money + 100 : config.round.money;
        army = initalizeArmy();
        nbUnits = config.round.maxUnits;
        // add title and shadow title
        selectionItems.shadowTitle = game.add.bitmapText(0, windowHeight / 2 - 300 + 3, 'font', 'SELECT YOUR UNITS', 40);
        selectionItems.shadowTitle.centerX = windowWidth / 2 + 3;
        selectionItems.shadowTitle.tint = 0xFF0000;
        selectionItems.title = game.add.bitmapText(0, windowHeight / 2 - 300, 'font', 'SELECT YOUR UNITS', 40);
        selectionItems.title.centerX = windowWidth / 2;
        // add line money
        selectionItems.text['money'] = game.add.bitmapText(0, windowHeight / 2 - 200, 'font', `${money} gold`, 30);
        selectionItems.text['money'].centerX = windowWidth / 3;
        // add line max units
        selectionItems.text['units'] = game.add.bitmapText(0, windowHeight / 2 - 200, 'font', `Units: ${config.round.maxUnits - nbUnits}/${config.round.maxUnits}`, 30);
        selectionItems.text['units'].centerX = windowWidth / 3 * 2;
        // add buttons selection
        let idx = 0 - listUnits.length / 2;
        for (const unit of listUnits) {
            addSelectionUnit(unit, idx);
            idx++;
        }
        // add description
        selectionItems.text['description'] = game.add.bitmapText(0, windowHeight / 2 + 300, 'font', "click on an unit to see its details", 30);
        selectionItems.text['description'].centerX = windowWidth / 2;
        // add button validate
        selectionItems.buttons['validate'] = game.add.button(0, windowHeight - 100, "validate", () => {createArmy()});
        selectionItems.buttons['validate'].scale.setTo(0.2, 0.2);
        selectionItems.buttons['validate'].centerX = windowWidth / 2;
    }

    function addSelectionUnit(unit, idx) {
        // unit asset
        selectionItems.buttons[unit] = game.add.button(windowWidth / 2 + (idx * 150), windowHeight / 2, unit, () => {displayUnitDetails(unit);});
        selectionItems.buttons[unit].scale.setTo(0.5, 0.5);
        // button more
        selectionItems.buttons[unit + "_more"] = game.add.button(0, 0, "more", () => {addUnit(unit);});
        selectionItems.buttons[unit + "_more"].scale.setTo(0.15, 0.15);
        selectionItems.buttons[unit + "_more"].centerX = selectionItems.buttons[unit].centerX;
        selectionItems.buttons[unit + "_more"].centerY = selectionItems.buttons[unit].centerY - selectionItems.buttons[unit].height / 2 - selectionItems.buttons[unit + "_more"].height / 2 - 10;
        // button less
        selectionItems.buttons[unit + "_less"] = game.add.button(0, 0, "less", () => {removeUnit(unit);});
        selectionItems.buttons[unit + "_less"].scale.setTo(0.15, 0.15);
        selectionItems.buttons[unit + "_less"].centerX = selectionItems.buttons[unit].centerX;
        selectionItems.buttons[unit + "_less"].centerY = selectionItems.buttons[unit].centerY + selectionItems.buttons[unit].height / 2 + selectionItems.buttons[unit + "_less"].height / 2 + 10;
        // number of units
        selectionItems.text[unit + "_number"] = game.add.bitmapText(0, 0, 'font', "x0", 30);
        selectionItems.text[unit + "_number"].centerX = selectionItems.buttons[unit].centerX;
        selectionItems.text[unit + "_number"].centerY = selectionItems.buttons[unit + "_less"].centerY + selectionItems.buttons[unit + "_less"].height / 2 + selectionItems.text[unit + "_number"].height / 2 + 10;
        // price on the icon
        selectionItems.text[unit + "_price"] = game.add.bitmapText(0, 0, 'font', config.units[unit].price, 30);
        selectionItems.text[unit + "_price"].centerX = selectionItems.buttons[unit + "_less"].centerX + selectionItems.buttons[unit + "_less"].width + 10;
        selectionItems.text[unit + "_price"].centerY = selectionItems.buttons[unit + "_more"].centerY + 10;
        selectionItems.text[unit + "_price"].tint = 0xE1C80D;
    }

    function initalizeArmy() {
        const newArmy = {};
        for (const unit of listUnits) {
            newArmy[unit] = 0;
        }
        return newArmy;
    }

    function destroySelection() {
        selectionItems.title.destroy();
        selectionItems.shadowTitle.destroy();
        for (const [buttonKey, buttonValue] of Object.entries(selectionItems.buttons)) {
            selectionItems.buttons[buttonKey].destroy();
        }
        for (const [textKey, textValue] of Object.entries(selectionItems.text)) {
            selectionItems.text[textKey].destroy();
        }
        selectionItems = initSelectionItems();
    }

    function displayUnitDetails(unit) {
        selectionItems.text['description'].text = config.units[unit].description;
        selectionItems.text['description'].centerX = windowWidth / 2;
    }

    function disaplayChange(unit) {
        selectionItems.text[unit + "_number"].text = `x${army[unit]}`;
        selectionItems.text[unit + "_number"].centerX = selectionItems.buttons[unit].centerX;
        selectionItems.text['money'].text = `${money} gold`;
        selectionItems.text['money'].centerX = windowWidth / 3;
        if (money === 0) {
            selectionItems.text['money'].tint = 0xFF0000;
        } else {
            selectionItems.text['money'].tint = 0xFFFFFF;
        }
        selectionItems.text['units'].text = `Units: ${config.round.maxUnits - nbUnits}/${config.round.maxUnits}`;
        selectionItems.text['units'].centerX = windowWidth / 3 * 2;
        if (nbUnits === 0) {
            selectionItems.text['units'].tint = 0xFF0000;
        }  else {
            selectionItems.text['units'].tint = 0xFFFFFF;
        }
    }

    function addUnit(unit) {
        if (validateArmy === false && money >= config.units[unit].price && nbUnits > 0) {
            army[unit]++;
            money -= config.units[unit].price;
            nbUnits--;
            disaplayChange(unit);
        }
    }

    function removeUnit(unit) {
        if (validateArmy === false && army[unit] > 0) {
            army[unit]--;
            money += config.units[unit].price;
            nbUnits++;
            disaplayChange(unit);
        }
    }

    function initSelectionItems() {
        return {
            title: null,
            shadowTitle: null,
            buttons: {},
            text: {}
        };
    }

    function createArmy() {
        validateArmy = true;
        selectionItems.buttons['validate'].destroy();
        delete selectionItems.buttons['validate'];
        const url = `${baseUrl}/create_army/${idRoom}?idPlayer=${idPlayer}`;
        sendRequest(url, "POST", JSON.stringify({
            leader: myLeader,
            army: army
        }));
    }

    /* _________________________________ SCENE 3 - ROUND _________________________________ */

    function displayGrid() {
        gameItems.text["turn"] = game.add.bitmapText(beginX, beginY - 80, 'font', '', 30);
        gameItems.text["statsLine"] = game.add.bitmapText(beginX, beginY - 50, 'font', '', 30);
        gameItems.graphics = game.add.graphics(beginX, beginY);
        gameItems.graphics.lineStyle(2, 0xFFFFFF, 1);
        gameItems.images["ground"] = [];
        for (let x = 0; x < sizeGrid; x++) {
            for (let y = 0; y < sizeGrid; y++) {
                gameItems.graphics.drawRect(x * sizeCell, y * sizeCell, sizeCell, sizeCell);
                const imgGround = game.add.image(beginX + (x * sizeCell), beginY + (y * sizeCell), "ground" + (1 + random(5)));
                imgGround.scale.setTo(0.17, 0.17);
                gameItems.images.ground.push(imgGround);
            }
        }
        gameItems.images["obstacles"] = [];
        for (const obstacle of statusGame.obstacles) {
            const x = (idPlayer === statusGame.firstPlayer) ? beginX + (obstacle.x * sizeCell) : beginX + ((14 - obstacle.x) * sizeCell);
            const y = (idPlayer === statusGame.firstPlayer) ? beginY + (obstacle.y * sizeCell) : beginY + ((14 - obstacle.y) * sizeCell);
            let imgObstacle = null;
            if (obstacle.type.includes("animation") === false) {
                imgObstacle = game.add.image(x, y, obstacle.type);
            } else {
                console.log(obstacle.type);
                imgObstacle = game.add.sprite(x, y, obstacle.type, 1);
                imgObstacle.scale.setTo(0.17, 0.17);
                const animation = imgObstacle.animations.add(obstacle.type);
                animation.play(3, true);
            }
            imgObstacle.scale.setTo(0.17, 0.17);
            gameItems.images.obstacles.push(imgObstacle);
        }
        gameItems.images["fog"] = [];
        const nextButton = game.add.button(beginX + sizeCell * (sizeGrid) + 10, beginY, "next", () => {skipTurn();});
        nextButton.scale.setTo(sizeCell / nextButton.width, sizeCell / nextButton.height);
        gameItems.buttons["next"] = nextButton;
    }

    function destroyGrid() {
        gameItems.graphics.destroy();
        if ("myArmy" in gameItems.buttons && "enemyArmy" in gameItems.buttons) {
            destroyArmies();
        }
        destroyButtonsMove();
        destroyArrayButtons("blocked");
        destroyArrayButtons("enemiesBorder");
        destroyArrayImages("obstacles");
        destroyArrayImages("ground");
        destroyArrayButtons("damaged");
        if ("next" in gameItems.buttons) {
            gameItems.buttons["next"].destroy();
        }
        for (const [textKey, textValue] of Object.entries(gameItems.text)) {
            gameItems.text[textKey].destroy();
        }
        gameItems = initGameItems();
    }

    function displayArmies() {
        if (statusGameChanged === false && sizeScreenChanged === false) {
            return;
        }
        if ("myArmy" in gameItems.buttons && "enemyArmy" in gameItems.buttons) {
            destroyArmies();
            destroyArrayButtons("blocked");
            destroyArrayButtons("enemiesBorder");
            destroyArrayButtons("damaged");
        }
        gameItems.buttons["myArmy"] = {};
        gameItems.buttons["enemyArmy"] = {};
        gameItems.buttons["blocked"] = [];
        gameItems.buttons["enemiesBorder"] = [];
        gameItems.buttons["damaged"] = [];
        for (const unit of statusGame.myArmy) {
            addUnitButton(unit, "myArmy", () => {event(unit)})
        }
        for (const unit of statusGame.enemyArmy) {
            addUnitButton(unit, "enemyArmy", () => {eventEnemy(unit)})
        }
        applyFog();
        if (beginTurn === true) {
            displayYourTurn();
            beginTurn = false;
        }
    }

    function displayAnimations() {
        listSprite = [];
        listAnimations = [];
        let idx = 0;
        for (const animation of statusGame.animations) {
            const animX = (idPlayer === statusGame.firstPlayer) ? beginX + (animation.x * sizeCell) : beginX + ((14 - animation.x) * sizeCell);
            const animY = (idPlayer === statusGame.firstPlayer) ? beginY + (animation.y * sizeCell) : beginY + ((14 - animation.y) * sizeCell);
            if (inVisionOfArmy(animation.x, animation.y) === true) {
                listSprite.push(game.add.sprite(animX, animY, animation.type, 1));
                listSprite[idx].scale.setTo(0.17, 0.17);
                listAnimations.push(listSprite[idx].animations.add(animation.type));
                listAnimations[idx].onComplete.add(() => {nbAnimations--;}, this);
                listAnimations[idx].play(animation.speed, false, true);
                idx++;
                nbAnimations++;
            }
        }
    }

    function addUnitButton(unit, army, event) {
        if (inVisionOfArmy(unit.x, unit.y) === false) {
            return;
        }
        const x = (idPlayer === statusGame.firstPlayer) ? beginX + (unit.x * sizeCell) : beginX + ((14 - unit.x) * sizeCell);
        const y = (idPlayer === statusGame.firstPlayer) ?  beginY  + (unit.y * sizeCell) : beginY  + ((14 - unit.y) * sizeCell);
        // add sprite unit
        const unitButton = game.add.button(x, y, unit.type, event);
        unitButton.scale.setTo(0.17, 0.17);
        gameItems.buttons[army][unit.idx] = unitButton;
        // add enemy border
        if (army === "enemyArmy") {
            const enemyBorder = game.add.button(x, y, "redBorder", event);
            enemyBorder.scale.setTo(0.15, 0.15);
            gameItems.buttons.enemiesBorder.push(enemyBorder);
        }
        // add blocked icon
        if (unit.hasAttacked === true) {
            const blockedButton = game.add.button(x, y, "blocked", event);
            blockedButton.scale.setTo(0.17, 0.17);
            gameItems.buttons.blocked.push(blockedButton);
        }
        // add damaged effect
        if (unit.hp < 3) {
            const damagedButton = game.add.button(x, y, "damaged", event);
            damagedButton.scale.setTo(0.17, 0.17);
            damagedButton.alpha = 0.3;
            gameItems.buttons.damaged.push(damagedButton);
        }
    }

    function inVisionOfArmy(x, y) {
        for (const unit of statusGame.myArmy) {
            if (x <= unit.x + (unit.move * 1.5 + unit.range) && x >= unit.x - (unit.move * 1.5 + unit.range) &&
                y <= unit.y + (unit.move * 1.5 + unit.range) && y >= unit.y - (unit.move * 1.5 + unit.range)) {
                    return true;
            }
        }
        return false;
    }

    function applyFog() {
        if ("fog" in gameItems.images) {
            destroyArrayImages("fog");
        }
        for (let x = 0; x < sizeGrid; x++) {
            for (let y = 0; y < sizeGrid; y++) {
                if (inVisionOfArmy(x, y) === false) {
                    const fogX = (idPlayer === statusGame.firstPlayer) ? beginX + (x * sizeCell) : beginX + ((14 - x) * sizeCell);
                    const fogY = (idPlayer === statusGame.firstPlayer) ? beginY + (y * sizeCell) : beginY + ((14 - y) * sizeCell);
                    const imgFog = game.add.image(fogX, fogY, "fog");
                    imgFog.scale.setTo(0.17, 0.17);
                    imgFog.alpha = 0.8;
                    gameItems.images.fog.push(imgFog);
                }
            }
        }
    }

    function destroyArmies() {
        for (const [buttonKey, buttonValue] of Object.entries(gameItems.buttons.myArmy)) {
            gameItems.buttons.myArmy[buttonKey].destroy();
        }
        for (const [buttonKey, buttonValue] of Object.entries(gameItems.buttons.enemyArmy)) {
            gameItems.buttons.enemyArmy[buttonKey].destroy();
        }
    }

    function destroyArrayButtons(type) {
        if (type in gameItems.buttons) {
            for (let idx = 0; idx < gameItems.buttons[type].length; idx++) {
                gameItems.buttons[type][idx].destroy();
            }
        }
    }

    function destroyArrayImages(type) {
        if (type in gameItems.images) {
            for (let idx = 0; idx < gameItems.images[type].length; idx++) {
                gameItems.images[type][idx].destroy();
            }
        }
    }

    function destroyButtonsMove() {
        destroyArrayButtons("move");
        selectedUnit = null;
    }

    function initGameItems() {
        return {
            graphics: null,
            buttons: {},
            text: {},
            images: {}
        };
    }

    function modifyName(name) {
        name = name.charAt(0).toUpperCase() + name.substring(1);
        while (name.indexOf("_") !== -1) {
            name = name.replace("_", " ");
        }
        return name;
    }

    function setLineText(unit, color) {
        gameItems.text.statsLine.text = `${modifyName(unit.type)} - HP: [${unit.hp}/${unit.maxHp}] DMG: [${unit.dmg}]`;
        gameItems.text.statsLine.tint = color;
    }

    function event(unit) {
        if (selectedUnit === null || selectedUnit !== unit.idx) {
            setLineText(unit, 0xFFFFFF);
            if (myTurn === true && unit.hasAttacked === false) {
                manageMove(unit);
                selectedUnit = unit.idx;
            }
        } else {
            destroyButtonsMove();
        }
    }

    function eventEnemy(unit) {
        if (selectedUnit === null || selectedUnit !== unit.idx * -1) {
            setLineText(unit, 0xFF0000);
            if (myTurn === true) {
                showRangeEnemy(unit);
                selectedUnit = unit.idx * -1;
            }
        } else {
            destroyButtonsMove();
        }
    }

    function isOnAllie(offsetX, offsetY, currentUnit, inMyArmy) {
        for (const unit of statusGame.myArmy) {
            if ((unit.idx !== currentUnit.idx || inMyArmy === false) && unit.x === offsetX && unit.y === offsetY) {
                return true;
            }
        }
        return false;
    }

    function isOnObstacle(x, y) {
        for (const obstacle of statusGame.obstacles) {
            if (x === obstacle.x && y === obstacle.y) {
                return true;
            }
        }
        return false;
    }

    function isOnEnemy(offsetX, offsetY) {
        for (const unit of statusGame.enemyArmy) {
            if (unit.x === offsetX && unit.y === offsetY) {
                return unit.idx;
            }
        }
        return -1;
    }

    // 0 - can move, shoot or attack
    // 1 - can't do anything
    // 2 - can't move but can shoot
    function behindObstacleOrEnemy(offsetX, offsetY, unit, inMyArmy, isMove) {
        let xTmp = unit.x;
        let yTmp = unit.y;
        const x = (xTmp < offsetX) ? 1 : -1;
        const y = (yTmp < offsetY) ? 1 : -1;

        while (xTmp !== offsetX || yTmp !== offsetY) {
            if (isOnObstacle(xTmp, yTmp) === true) {
                return 1;
            } else if (isMove === true) {
                const status = (unit.type === "bowman" || unit.type === "crossbowman" || unit.type === "doctor") ? 2 : 1;
                if ((xTmp !== unit.x || yTmp !== unit.y) && isOnEnemy(xTmp, yTmp) !== -1) {
                    return status;
                } else if (isOnAllie(xTmp, yTmp, unit, inMyArmy) === true) {
                    return status;
                }
            }
            if (xTmp !== offsetX) {
                xTmp += x;
            }
            if (yTmp !== offsetY) {
                yTmp += y;
            }
        }
        return 0;
    }

    function haveToDisplayMove(offsetX, offsetY, unit, inMyArmy) {
        if (offsetX === unit.x && offsetY === unit.y) {
            return false;
        } else if (offsetX < 0 || offsetX >= sizeGrid) {
            return false;
        } else if (offsetY < 0 || offsetY >= sizeGrid) {
            return false;
        } else if (inMyArmy === true && isOnAllie(offsetX, offsetY, unit, inMyArmy) === true) {
            return false;
        } else if (inMyArmy === false && isOnEnemy(offsetX, offsetY) !== -1) {
            return false;
        } else if (isOnObstacle(offsetX, offsetY) === true) {
            return false;
        } else {
            return true;
        }
    }

    function isMove(offsetX, offsetY, unit) {
        if ((offsetX >= unit.x - unit.move && offsetX <= unit.x + unit.move) && (offsetY >= unit.y - unit.move && offsetY <= unit.y + unit.move)) {
            return true;
        } else {
            return false;
        }
    }

    function manageMove(unit) {
        if ("move" in gameItems.buttons) {
            destroyButtonsMove();
        }
        gameItems.buttons["move"] = [];
        for (let offsetX = unit.x - (unit.move + unit.range); offsetX <= unit.x + (unit.move + unit.range); offsetX++) {
            for (let offsetY = unit.y - (unit.move + unit.range); offsetY <= unit.y + (unit.move + unit.range); offsetY++) {
                const statusBehindObastacle = behindObstacleOrEnemy(offsetX, offsetY, unit, true, isMove(offsetX, offsetY, unit));
                if (statusBehindObastacle === 1) {
                    continue;
                }
                const idxEnemy = isOnEnemy(offsetX, offsetY);
                const x = (idPlayer === statusGame.firstPlayer) ? beginX + (offsetX * sizeCell) : beginX + ((14 - offsetX) * sizeCell);
                const y = (idPlayer === statusGame.firstPlayer) ?  beginY  + (offsetY * sizeCell) : beginY  + ((14 - offsetY) * sizeCell);
                if (idxEnemy !== -1) {
                    const buttonMove = game.add.button(x, y, 'attack', () => {attackEnemy(unit, idxEnemy)});
                    buttonMove.scale.setTo(0.17, 0.17);
                    gameItems.buttons["move"].push(buttonMove);
                } else if (haveToDisplayMove(offsetX, offsetY, unit, true)) {
                    let buttonMove = null;
                    if (statusBehindObastacle === 0 && isMove(offsetX, offsetY, unit) === true) {
                        buttonMove = game.add.button(x, y, 'move', () => {moveUnit(unit, offsetX, offsetY)});
                    } else if (statusBehindObastacle !== 1) {
                        buttonMove = game.add.button(x, y, 'range', () => {});
                    }
                    buttonMove.scale.setTo(0.17, 0.17);
                    gameItems.buttons["move"].push(buttonMove);
                }
            }
        }
    }

    function showRangeEnemy(unit) {
        if ("move" in gameItems.buttons) {
            destroyButtonsMove();
        }
        gameItems.buttons["move"] = [];
        for (let offsetX = unit.x - (unit.move + unit.range); offsetX <= unit.x + (unit.move + unit.range); offsetX++) {
            for (let offsetY = unit.y - (unit.move + unit.range); offsetY <= unit.y + (unit.move + unit.range); offsetY++) {
                if (inVisionOfArmy(offsetX, offsetY) === false) {
                    continue;
                }
                const statusBehindObastacle = behindObstacleOrEnemy(offsetX, offsetY, unit, false, isMove(offsetX, offsetY, unit));
                if (statusBehindObastacle === 1) {
                    continue;
                }
                const canMove = haveToDisplayMove(offsetX, offsetY, unit, false);
                if (canMove === true) {
                    const x = (idPlayer === statusGame.firstPlayer) ? beginX + (offsetX * sizeCell) : beginX + ((14 - offsetX) * sizeCell);
                    const y = (idPlayer === statusGame.firstPlayer) ?  beginY  + (offsetY * sizeCell) : beginY  + ((14 - offsetY) * sizeCell);
                    const buttonMove = game.add.button(x, y, 'enemyRange', () => {destroyButtonsMove();});
                    buttonMove.scale.setTo(0.17, 0.17);
                    if (isOnAllie(offsetX, offsetY, unit, false) === true) {
                        buttonMove.alpha = 0.5;
                    }
                    gameItems.buttons["move"].push(buttonMove);
                }
            }
        }   
    }

    function attackEnemy(unit, idxEnemy) {
        destroyButtonsMove();
        const url = `${baseUrl}/attack/${idRoom}?idPlayer=${idPlayer}`;
        const body = {
            idx: unit.idx,
            idxEnemy: idxEnemy
        }
        sendRequest(url, "POST", JSON.stringify(body));
    }

    function moveUnit(unit, offsetX, offsetY) {
        destroyButtonsMove();
        const url = `${baseUrl}/move/${idRoom}?idPlayer=${idPlayer}`;
        const body = {
            idx: unit.idx,
            x: offsetX,
            y: offsetY
        }
        sendRequest(url, "POST", JSON.stringify(body));
    }

    function everyUnitHasAttacked() {
        for (const unit of statusGame.myArmy) {
            if (unit.hasAttacked === false) {
                return false;
            }
        }
        return true;
    }

    function checkTurnOver() {
        if (myTurn === true) {
            if (statusGame.nbActions <= 0 || everyUnitHasAttacked() === true) {
                const url = `${baseUrl}/turn_over/${idRoom}?idPlayer=${idPlayer}`;
                sendRequest(url, "GET");
                gameItems.text["turn"].text = `Enemy's turn - ${statusGame.nbActions}/${statusGame.maxNbActions}`;
                gameItems.text["turn"].tint = 0xFF0000;
            } else {
                gameItems.text["turn"].text = `Your turn - ${statusGame.nbActions}/${statusGame.maxNbActions}`;
                gameItems.text["turn"].tint = 0xFFFFFF;
            }
        } else {
            gameItems.text["turn"].text = `Enemy's turn - ${statusGame.nbActions}/${statusGame.maxNbActions}`;
            gameItems.text["turn"].tint = 0xFF0000;
        }
    }

    function skipTurn() {
        if (myTurn === true) {
            destroyButtonsMove();
            const url = `${baseUrl}/turn_over/${idRoom}?idPlayer=${idPlayer}`;
            sendRequest(url, "GET");
        }
    }

    function displayYourTurn() {
        const yourTurn = game.add.sprite(0, 0, 'animationYourTurn', 1);
        // yourTurn.scale.setTo(0.7, 0.5)
        yourTurn.centerX = windowWidth / 2;
        yourTurn.centerY = windowHeight / 2;
        // sleep ?
        const animation = yourTurn.animations.add('yourTurn');
        animation.play(5, false, true);
    }

    /* _________________________________ SCENE 4 - WINNER _________________________________ */

    function displayWinner(idWinner) {
        // add title and icon
        winnerItems.title = game.add.bitmapText(0, 0, 'font', '', 40);
        winnerItems.icon = game.add.image(0, 0, myLeader);
        if (idWinner === idPlayer) {
            winnerItems.title.text = "YOU WIN !";
            winnerItems.icon.scale.setTo(0.5, 0.5);
        } else {
            winnerItems.title.text = "YOU LOSE";
            winnerItems.icon.scale.setTo(0.5, -0.5);
        }
        winnerItems.title.centerX = windowWidth / 2;
        winnerItems.title.centerY = windowHeight / 2;
        winnerItems.icon.centerX = windowWidth / 2;
        winnerItems.icon.centerY = windowHeight / 2 - winnerItems.icon.height;
        // add button back
        winnerItems.buttonBack = game.add.button(0, 0, "back", () => {backToMenuFromEnd();});
        winnerItems.buttonBack.scale.setTo(0.17, 0.17);
        winnerItems.buttonBack.centerX = windowWidth / 2 - winnerItems.title.width;
        winnerItems.buttonBack.centerY = windowHeight / 2;
        // add button retry
        winnerItems.buttonRetry = game.add.button(0, 0, "retry", () => {retry();});
        winnerItems.buttonRetry.scale.setTo(0.17, 0.17);
        winnerItems.buttonRetry.centerX = windowWidth / 2 + winnerItems.title.width;
        winnerItems.buttonRetry.centerY = windowHeight / 2;
    }

    function reInit(newIdRoom, newStatusRoom) {
        idRoom = newIdRoom;
        statusRoom = 0;
        statusGame = null;
        statusGameChanged = null;
        myTurn = null;
        validateArmy = false;
    }

    function backToMenuFromEnd() {
        reInit(null);
        destroyWinnerMenu();
        displayMenu();
    }

    function retry() {
        reInit(idRoom);
        destroyWinnerMenu();
        const response = sendRequest(`${baseUrl}/reinit_room/${idRoom}?idPlayer=${idPlayer}`, "GET");
        if (response.firstToRetry === false) {
            displaySelectionLeader();
        }
    }

    function destroyWinnerMenu() {
        winnerItems.title.destroy();
        winnerItems.icon.destroy();
        winnerItems.buttonRetry.destroy();
        winnerItems.buttonBack.destroy();
        winnerItems = initWinnerItems();
    }

    function initWinnerItems() {
        return {
            title: null,
            icon: null,
            buttonRetry: null,
            buttonBack: null
        }
    }

    /* _________________________________ TOOLS _________________________________ */

    function responsive() {
        if (windowWidth !== window.innerWidth || windowHeight !== window.innerHeight) {
            console.log(`${windowWidth} -> ${window.innerWidth} and ${windowHeight} -> ${window.innerHeight}`);
            sizeScreenChanged = true;
            windowWidth = window.innerWidth;
            windowHeight = window.innerHeight;
            game.width = windowWidth;
            game.height = windowHeight;
            if (idRoom === null) {
                console.log('MENU');
                destroyMenu();
                displayMenu();
            } else if (statusRoom === 1) {
                console.log('WAITING');
                destroyWaiting();
                displayWaiting();
            } else if (statusRoom === 2) { // penser a un systeme pour leader (if leader = null)
                console.log('SELECTION');
                destroySelection();
                displaySelection();
            } else {
                console.log('GRID');
                destroyGrid();
                displayGrid();
                displayArmies();
            }
            sizeScreenChanged = false;
        }
    }

    function sendRequest(url, method, body=null) {
        const req = new XMLHttpRequest();
        req.open(method, url, false);
        if (method === "POST") {
            req.setRequestHeader("content-type", "application/json");
        }
        req.send(body);
        return JSON.parse(req.response);
    }

    function random(max) {
        return Math.floor(Math.random() * Math.floor(max));
    }
    
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

</script>

</body>
</html>